---
author: zhangman523
comments: true
date: 2016-03-01 21:32:31+00:00
layout: post
slug: HashMap 解析
title: HashMap 解析
tags:
- Android
categories:
- Android 笔记
---

### HashMap 概述

`HaspMap` 是 基于`哈希表`的[`Map接口`](https://developer.android.google.cn/reference/java/util/Map.html)实现，提供了所有的Map操作并且允许`key`和`value`为`null`。（`HashMap`大致等同于`HashTable`,除了`HashMap`不是同步的和允许为null）`HashMap`不保证`Map`中的排序顺序；尤其是不能保证排序在一段时间内保持不变。

`HashMap`的这个实现为基本操作提供了恒定的性能（`get`和`put`）,假设哈希函数在`buckets`之间正确地分散元素。对集合视图的迭代需要的时间与`HashMap`实例的“容量”（`buckets`的数量）加上其大小（键值映射的数量）成正比。因此，如果迭代性能很重要，不要将初始容量设置得太高（或者负载因子太低）。

>`buckets` 其实就是 `transient Node<K,V>[] table;`这个。其中Node 保存的数据区
`final int hash;` 通过key计算出的hash值
`final K key;`  key
`V value;`	value
`Node<K,V> next;` 

`HashMap`的有两个影响其性能的参数:初始容量(initialCapacity)和负载因数(loadFactor)。容量就是`buckets`的数量,初始容量就是哈希表创建时的容量。负载因子:当哈希表容量达到`(负载因子*容量)` 就会自动增加容量.如果哈希表中条目的数量超过了负载因子和当前容量的乘积,哈希表被`rehash`(即内部的数据结构将被重建)所以哈希表大约有两倍的容量。

通常来说，默认的负载因子(.75)在时间和空间成本之间提供了一个很好的折中。负载因子越高会减少空间开销，但会增加查找成本（反映在大部分HashMap类的操作中，包括get和put）在设定其初始容量时，应考虑Map中预期的条目数量及其装载因子，以尽量减少`rehash`的次数。如果初始容量大于最大容量除以负载因子，则不会`rehash`操作。

### HashMap 实现
{% highlight java linenos %}
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {
    ...
}
{% endhighlight %}

### HashMap 构造方法
`HashMap` 有4个构造方法

- `HashMap(int initialCapacity, float loadFactor)` 用指定的初始容量和负载因子构造一个空的HashMap
{% highlight java linenos %}
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " + loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}
{% endhighlight %}

- `HashMap(int initialCapacity)` 用指定的初始容量创建一个空的HashMap
{% highlight java linenos %}
 public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}
{% endhighlight %}

- `HashMap()` 使用默认初始容量（16）和默认加载因子（0.75）创建一个空的HashMap。
{% highlight java linenos %}
public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}
{% endhighlight %}

- `HashMap(Map<? extends K, ? extends V> m)` 使用与指定的Map相同的映射构造一个新的HashMap。
{% highlight java linenos %}
public HashMap(Map<? extends K, ? extends V> m) {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
}    
{% endhighlight %}

